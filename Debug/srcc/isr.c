//=====================================================================
//文件名称：isr.c（中断处理程序源文件）
//框架提供：SD-ARM（sumcu.suda.edu.cn）
//版本更新：20170801-20191020
//功能描述：提供中断处理程序编程框架
//=====================================================================
#include "includes.h"
//声明使用到的内部函数
//isr.c使用的内部函数声明处
void SecAdd1(uint8_t *p);
//======================================================================
//函数名称：UART_UE_Handler
//参数说明：无
//函数返回：无
//功能概要：串口UE接收中断服务程序
//======================================================================
void UART_UE_Handler(void)
{
	uint8_t ch;
	uint8_t flag;
	DISABLE_INTERRUPTS;      //关总中断
	//-------------------------------
    //接收一个字节
	ch = uart_re1(UART_UE, &flag);   //调用接收一个字节的函数，清接收中断位
	uart_send1(UART_2,ch);
	//串口数据接收失败，退出
	if(!flag) goto UART_UE_IRQHandler_Exit;
	//gcRecvLen为0，表示上一帧数据处理接收，可重新接收数据
	if(gcRecvLen == 0)                           //组帧
		wifi_int_re(ch, &gcRecvLen, gcRecvBuf);
	else                                         //丢弃
		goto UART_UE_IRQHandler_Exit;
	//未接收到服务器发来的数据，退出
	if(gcRecvLen == 0) goto UART_UE_IRQHandler_Exit1;
    //已经收到一帧字节数为gcRecvLen，在gcRecvBuf中，由main.c处理
	//printf("strncmpbefore\r\n");
//    if(strncmp((char *)(gcRecvBuf),(char *)((MCU_SECTOR_NUM-1)*MCU_SECTORSIZE+
//       MCU_FLASH_ADDR_START),16) != 0)
//    {
//        goto UART_UE_IRQHandler_Exit;
//    }
//    //（4）至此，不仅收到完整帧，且序号比较也一致， 根据命令字节gcRecvBuf[16]进行跳转
//    //若为User串口程序更新命令，则进行程序更新
    switch(gcRecvBuf[16])  //帧标识
    {	
        case 'T':
            SYSTEM_FUNCTION((uint8_t *)(gcRecvBuf+17));
            gcRecvLen = 0;         //恢复接收状态
        break;
        case 'R':
        	NVIC_SystemReset();
        	break;
        default:
        goto UART_UE_IRQHandler_Exit1;
        break;
    }
UART_UE_IRQHandler_Exit:
	gcRecvLen = 0;  
	UART_UE_IRQHandler_Exit1:
	//-------------------------------
	ENABLE_INTERRUPTS;       //开总中断

    return;
}




//=====================================================================
//函数名称：TIMER_USER_Handler（TPM1定时器中断处理程序）
//参数说明：无
//函数返回：无
//功能概要：（1）每20ms中断触发本程序一次；（2）达到一秒时，调用秒+1
//           程序，计算“时、分、秒”
//特别提示：（1）使用全局变量字节型数组gTime[3]，分别存储“时、分、秒”
//        （2）注意其中静态变量的使用
//=====================================================================
void TIMER_USER_Handler(void)
{
	DISABLE_INTERRUPTS;                        //关总中断
	//------------------------------------------------------------------
	//（在此处增加功能）
	//申请一个静态的计数器值
	static uint8_t TimerCount = 0;
	//获取当前时钟溢出标志位
	if(timer_get_int(TIMER_USER))
	{
		TimerCount++;           //计数器累加
		if (TimerCount >= 50)
		{
			TimerCount = 0;    //时钟计数器清零
			SecAdd1(gTimeString);    //时间显示累加
		}
		timer_clear_int(TIMER_USER);    //清时钟溢出标志位
	}
	//------------------------------------------------------------------
	ENABLE_INTERRUPTS;                        //开总中断

}


//===========================================================================
//函数名称：SecAdd1
//函数返回：无
//参数说明：*p:为指向一个时分秒数组p[3]
//功能概要：秒单元+1，并处理时分单元（00:00:00-23:59:59)
//2020-01-01 00:00:00 19位ASCII码
//===========================================================================
void SecAdd1(uint8_t *p)
{
    *(p+18)+=1;             //秒个位
    if((*(p+18)>0x39))     //秒个位满十
    {
      *(p+18)=0x30;
      *(p+17)+=1;          //秒十位
      if((*(p+17)>0x35))   //秒十位=6，分个位+1
      {
        *(p+18)=0x30;
        *(p+17)=0x30;
        *(p+15)+=1;
        if((*(p+15)>0x39))  //分个位满十，分个位，秒十位，个位归0，分十位+1
        {
          *(p+18)=0x30;
          *(p+17)=0x30;
          *(p+15)=0x30;
          *(p+14)+=1;
          if((*(p+14)>0x35))   //分十位=6，时个位+1，分秒归0
          {
            *(p+18)=0x30;
            *(p+17)=0x30;
            *(p+15)=0x30;
            *(p+14)=0x30;
            *(p+12)+=1;
            if((*(p+12)>0x39))  //时个位满十，时十位加1，分秒归0
            {
              if( (*(p+11))<0x32)
              {
                *(p+18)=0x30;
                *(p+17)=0x30;
                *(p+15)=0x30;
                *(p+14)=0x30;
                *(p+12)=0x30;
                *(p+11)+=1;
              }


            }

          }
        }

      }
    }
}

/*
 知识要素：
 1.本文件中的中断处理函数调用的均是相关设备封装好的具体构件，在更换芯片
 时，只需保证设备的构件接口一致，即可保证本文件的相关中断处理函数不做任何
 更改，从而达到芯片无关性的要求。
 */
